@charset "UTF-8";

//      A simple mixin library for Sass
//
//                http://growcss.de
//
//         Authors: Daniel Bannert (@anolilab)
//
//      This project is licensed under the terms of the MIT license
// - - - - - - - - - - - - - - - - - - - - - - - - -

/// Namespace
$config-namespace: "i-" !global;

/// Colors
///
$gray20: #333;

/// Global variable for em.
@include config-set("base-em", 16px, true);

@include config-set("background-clip", "padding-box", true);
@include config-set("background-origin", "content-box", true);
@include config-set("background-size", 100% auto, true);

@include config-set("border-radius", rem(5), true);
@include config-set("border-opacity", "padding-box", true);


@include config-set("box-shadow-inset", null, true);
@include config-set("box-shadow-h-offset", 0, true);
@include config-set("box-shadow-v-offset", 0, true);
@include config-set("box-shadow-blur", 5px, true);
@include config-set("box-shadow-spread", null, true);
@include config-set("box-shadow-color", $gray20, true);


/// Global variables to enable or disable vendor prefixes.
@include config-set("prefix.webkit", true, true);
@include config-set("prefix.mozilla", true, true);
@include config-set("prefix.microsoft", true, true);
@include config-set("prefix.opera", true, true);
@include config-set("prefix.spec", true, true);

/// Remove all non-true value of a list.
///
@function compact($list...) {
  $result: ();

  @each $item in $list {
    @if $item != null and $item != false and $item != "" {
      $result: append($result, $item);
    }
  }

  @return $result;
}

/// Function checking if $value is a valid length
///
/// @param {mixed} $value: value to test
///
/// @return {bool}
@function is-valid-length($value) {
  @return (type-of($value) == "number" and not unitless($value))
       or (index(auto initial inherit 0, $value) != false);
}

/// Convert pixels to ems
/// eg. for a relational value of 12px write em(12) when the parent is 16px
/// if the parent is another value say 24px write em(12, 24)
@function em($pxval, $base: config-get("i-base-em")) {
  @if not unitless($pxval) {
    $pxval: strip-units($pxval);
  }

  @if not unitless($base) {
    $base: strip-units($base);
  }

  @return ($pxval / $base) * 1em;
}

/// Convert pixels to rems
/// eg. for a relational value of 12px write rem(12)
/// Assumes $em-base is the font-size of <html>
@function rem($pxval) {
  @if not unitless($pxval) {
    $pxval: strip-units($pxval);
  }

  $base: config-get("i-base-em");

  @if not unitless($base) {
    $base: strip-units($base);
  }

  @return ($pxval / $base) * 1rem;
}

/// Strips the unit from a number.
///
/// @param {Number (With Unit)} $value
///
/// @example scss - Usage
///   $dimension: strip-units(10em);
///
/// @example css - CSS Output
///   $dimension: 10;
///
/// @return {Number (Unitless)}
@function strip-units($value) {
  @return ($value / ($value * 0 + 1));
}

/// Converts shorthand to the 4-value syntax.
///
/// @param {list} $shorthand
///
/// @example scss - Usage
///   .element {
///     margin: unpack(1em 2em);
///   }
///
/// @example css - CSS Output
///   .element {
///     margin: 1em 2em 1em 2em;
///   }
@function unpack($shorthand) {
  @if length($shorthand) == 1 {
    @return nth($shorthand, 1) nth($shorthand, 1) nth($shorthand, 1) nth($shorthand, 1);
  } @else if length($shorthand) == 2 {
    @return nth($shorthand, 1) nth($shorthand, 2) nth($shorthand, 1) nth($shorthand, 2);
  } @else if length($shorthand) == 3 {
    @return nth($shorthand, 1) nth($shorthand, 2) nth($shorthand, 3) nth($shorthand, 2);
  } @else {
    @return $shorthand;
  }
}

/// Checks if a list contains a value(s).
///
/// @param {list} $list
///   The list to check against.
///
/// @param {list} $values
///   A single value or list of values to check for.
///
/// @example scss - Usage
///   contains($list, $value)
///
/// @return {bool}
@function contains($list, $values...) {
  @if not is-list($list) {
    @warn "argument error: #{$list}";
    @return "error";
  }

  @each $value in $values {
    @if type-of(index($list, $value)) != "number" {
      @return false;
    }
  }

  @return true;
}

/// Find Opposite Direction
@function grider-opposite-direction($dir) {
  @if $dir == "left" {
    @return right;
  } @else if  $dir == "right" {
    @return left;
  } @else if $dir == "LTR" {
    @return rtl;
  } @else if $dir == "RTL" {
    @return ltr;
  } @else if $dir == "top" {
    @return bottom;
  } @else if $dir == "bottom" {
    @return top;
  } @else {
    @warn "#{$dir} is not a direction! Make sure your direction is all lowercase!";
    @return false;
  }
}

/// Find Direction Name
@function grider-named-direction($dir) {
  @if $dir == "LTR" {
    @return left;
  } @else if $dir == "RTL" {
    @return right;
  } @else {
    @warn "#{$dir} is not a valid HTML direction! Make sure you are using a valid HTML direction";
    @return false;
  }
}

///
///
/// @param {string} $val
/// @param {string} $unit
///
@function fallback-to-px($val, $unit: rem) {
  $output: ();

  @if type-of($val) == "string" {
    @if $val == "auto" or $val == "!important" {
      $output: join($val, $val);
      @return $output;
    }
  } @else {
    @if $val == 0 {
      $output: join(0, 0);
    } @else if unitless($val) {
      $output: join($val * config-get("i-base-em"), $val + $unit);
    } @else {
      $output: join($val, $val);
    }

    @return $output;
  }

  @warn "#{$val} is not a valid value";
  @return false;
}

/// Checks for a valid number.
///
/// @param {number} $value
///
/// @require {function} contains
@function is-number($value) {
  @return contains("0" "1" "2" "3" "4" "5" "6" "7" "8" "9" 0 1 2 3 4 5 6 7 8 9, $value);
}

/// Returns the legacy value for a given box-model
///
/// @access private
@function legacy-box($box) {
  $box: unquote($box);

  @if $box == padding-box {
    $box: padding;
  }

  @if $box == border-box {
    $box: border;
  }

  @if $box == content-box {
    $box: content;
  }

  @return $box;
}

/// A mixin for generating vendor prefixes on non-standardized properties.
///
/// @param {string} $property
///   Property to prefix
///
/// @param {*} $value
///   Value to use
///
/// @param {list} $prefixes
///   Prefixes to define
///
/// @example scss - Usage
///   .element {
///     @include prefixer(keyframes identifier, webkit ms spec) {
///       0% { top: 0; left: 0; }
///       30% { top: 50px; }
///       68%, 72% { left: 50px; }
///       100% { top: 100px; left: 100%; }
///     }
///   }
///
/// @example css - CSS Output
///   .element {
///     @-webkit-keyframes identifier {
///       0% { top: 0; left: 0; }
///       30% { top: 50px; }
///       68%, 72% { left: 50px; }
///       100% { top: 100px; left: 100%; }
///     }
///     @-moz-keyframes identifier {
///       0% { top: 0; left: 0; }
///       30% { top: 50px; }
///       68%, 72% { left: 50px; }
///       100% { top: 100px; left: 100%; }
///     }
///     @keyframes identifier {
///       0% { top: 0; left: 0; }
///       30% { top: 50px; }
///       68%, 72% { left: 50px; }
///       100% { top: 100px; left: 100%; }
///     }
///   }
///
@mixin prefixer-content($property, $prefixes) {
  @each $prefix in $prefixes {
    @if $prefix == webkit and config-get("i-prefix.webkit") {
      -webkit-#{$property} {
        @content;
      }
    } @else if $prefix == moz and config-get("i-prefix.mozilla") {
      -moz-#{$property} {
        @content;
      }
    } @else if $prefix == ms and config-get("i-prefix.microsoft") {
      -ms-#{$property} {
        @content;
      }
    } @else if $prefix == o and config-get("i-prefix.opera") {
      -o-#{$property} {
        @content;
      }
    } @else if $prefix == spec and config-get("i-prefix.spec") {
      #{$property} {
        @content;
      }
    } @else  {
      @warn "Unrecognized prefix: #{$prefix}";
    }
  }
}

/// A mixin for generating vendor prefixes on non-standardized properties.
///
/// @param {string} $property
///   Property to prefix
///
/// @param {*} $value
///   Value to use
///
/// @param {list} $prefixes
///   Prefixes to define
///
/// @example scss - Usage
///   .element {
///     @include prefixer(border-radius, 10px, webkit ms spec);
///   }
///
/// @example css - CSS Output
///   .element {
///     -webkit-border-radius: 10px;
///     -moz-border-radius: 10px;
///     border-radius: 10px;
///   }
///
@mixin prefixer($property, $value, $prefixes) {
  @each $prefix in $prefixes {
    @if $prefix == webkit and config-get("i-prefix.webkit") {
      -webkit-#{$property}: $value;
    } @else if $prefix == moz and config-get("i-prefix.mozilla") {
      -moz-#{$property}: $value;
    } @else if $prefix == ms and config-get("i-prefix.microsoft") {
      -ms-#{$property}: $value;
    } @else if $prefix == o and config-get("i-prefix.opera") {
      -o-#{$property}: $value;
    } @else if $prefix == spec and config-get("i-prefix.spec") {
      #{$property}: $value;
    } @else {
      @warn "Unrecognized prefix: #{$prefix}";
    }
  }
}

@mixin disable-prefixes() {
  @include config-set("prefix.webkit", false, true);
  @include config-set("prefix.mozilla", false, true);
  @include config-set("prefix.microsoft", false, true);
  @include config-set("prefix.opera", false, true);
  @include config-set("prefix.spec", false, true);
}

/// A simple shortcode for border.
///
/// @example scss - Usage
///   .example-basic-border {
///     @include shorthand-border(1px, #000);
///   }
///
///   .example-4sided-border  {
///     @include shorthand-border(1px 1px 0px 1px, #ccc #000, dashed);
///   }
///
///   .example-4color-border  {
///     @include shorthand-border(1px, #ccc #000 #333 #555);
///   }
///
///   .example-2style-border {
///     @include shorthand-border(1px, #000, solid dashed);
///   }
///
/// @example css - CSS Output
///   .example-basic-border {
///     border: 1px solid black;
///   }
///
///   .example-4sided-border {
///     border-width: 1px 1px 0px 1px;
///     border-style: dashed;
///     border-color: #cccccc black;
///   }
///
///   .example-4color-border {
///     border-width: 1px;
///     border-style: solid;
///     border-color: #cccccc black #333333 #555555;
///   }
///
///   .example-2style-border {
///     border-width: 1px;
///     border-style: solid dashed;
///     border-color: black;
///   }
@mixin border($border-width: config-get("i-border-width"), $border-color: config-get("i-border-color"), $border-style: config-get("i-border-style")) {
  @if length($border-width) > 1 {
    border-width: $border-width;
    border-style: $border-style;
    border-color: $border-color;
  } @else if length($border-style) > 1 {
    border-width: $border-width;
    border-style: $border-style;
    border-color: $border-color;
  } @else if length($border-color) > 1 {
    border-width: $border-width;
    border-style: $border-style;
    border-color: $border-color;
  } @else  {
      border: $border-width $border-style $border-color;
  }
}

/// Replaces ending of text with "..." when it
/// no longer fits in the container element.
///
/// @example scss - Usage
///   .text-container {
///     @extend %dotdotdot;
///   }
@mixin dotdotdot() {
  max-width: 100%;          /// Disallow expansion beyond parent container
  overflow: hidden;         /// Must be different from 'visible'
  text-overflow: ellipsis;  /// This is where the magic happens
  white-space: nowrap;      /// Allow one line of text only
}

/// Generate position properties in shorthand form.
///
/// @param {List}   $values         List of numbers or `auto`
/// @param {List}   $sides          List of sides (`top`, `left`, `bottom`, `right` or `all`)
/// @param {String} $pos            Position keyword or `none`
/// @param {Bool}   $auto-overwrite If `true` all non specified $sides will be set to `auto`
///
/// NOTE: `$values` get mapped to `$sides` in the order they are declared, see usage below
///
/// https:///gist.github.com/nicolas-cusan/8fc0cef0f466f6ca2ebc
///
/// @example scss - Usage
/// .my-class {
///   @include position(0, top left);
/// }
///
/// @example css - CSS Output
/// .my-class {
///   position: fixed;
///   top: 0;
///   left: 0;
///   right: 0;
///   bottom: 0;
/// }
///
/// @example scss - Usage
/// .my-class {
///   @include position(auto 200px 3em, top left right);
/// }
///
/// @example css - CSS Output
/// .my-class {
///   position: absolute;
///   top: auto;
///   left: 200px;
///   right: 3em;
/// }
///
/// @example scss - Usage
/// .my-class {
///   @include position(0 3px, left top, none);
/// }
///
/// @example css - CSS Output
/// .my-class {
///   top: 3px;
///   left: 0;
/// }
///
/// @example scss - Usage
/// .my-class {
///   @include position(0 200px, top left, $auto-overwrite: true);
/// }
///
/// @example css - CSS Output
/// .my-class {
///   position: absolute;
///   top: 0;
///   left: 200px;
///   right: auto;
///   bottom: auto;
/// }
@mixin position($values, $sides, $pos: absolute, $auto-overwrite: false) {
  /// Vars
  $positions: absolute, relative, fixed, static;
  $map: (bottom: null, left: null, right: null, top: null);

  /// Set everything to auto to overwrite other styles.
  /// Edge case but can be useful.
  @if $auto-overwrite {
    $map: (bottom: auto, left: auto, right: auto, top: auto);
  }

  /// Validate `$values` & `$sides` input and warn (input gets rendered though)
  @each $value in $values {
    @if type-of($value) == number or $value == auto {} @else {
      @warn "Invalid amount: #{$value}";
    }
  }

  @each $side in $sides {
    @if index(map-keys($map), $side) or $side == all {} @else {
      @warn "Invalid side: #{$side}";
    }
  }

  /// Render & Validate `$pos`
  @if index($positions, $pos) {
    position: $pos;
  } @else if $pos != none {
    @warn "The $pos argument is invalid, use `absolute`, `fixed`, `relative`, `static`, or `none` (invalid value: #{$pos})";
  }

  /// Populate the map with `$sides`
  @if $sides == all and length($values) == 1 {
    bottom: $values; left: $values; right: $values; top: $values;
  } @else if length($sides) == length($values) {
    @for $i from 1 through length($sides) {
      $map: map-merge($map, (nth($sides, $i):nth($values, $i)));
    }
  } @else if length($values) == 1 {
    @for $i from 1 through length($sides) {
      $map: map-merge($map, (nth($sides, $i):$values));
    }
  } @else {
    @warn "The number of $values has to match the $sides or be a single value";
  }

  /// Render (properties with value `null` don"t get rendered)
  @each $key, $val in $map {
    #{$key}: #{$val};
  }
}

/// This mixin outputs a property with rem or em units and a px fallback.
/// Values passed without units are used as multipliers for the final
/// rem or em and px values, all other units are output without modification.
///
/// @param {string} $prop
/// @param {list}   $vals
/// @param {string} $unit
///
/// @example scss - Usage
///   @include px-and-unit([property], [multiplier | explicit value] [, ...]);
///
/// @example scss - Usage
///   .margin {
///     @include px-and-unit(margin, 2);
///   }
///
/// @example css - CSS Output
///   .margin {
///     margin: 32px;
///     margin: 2rem;
///   }
@mixin px-and-unit($prop, $vals, $unit: rem) {
  $px-list: ();
  $em-list: ();

  @each $val in $vals {
    $calcs: fallback-to-px($val, $unit);
    $px-list: append($px-list, nth($calcs, 1));
    $em-list: append($em-list, nth($calcs, 2));
  }

  #{$prop}: $px-list;
  #{$prop}: $em-list;
}

// Each of these mixins support comma separated lists of values, which allows different transitions for individual properties to be described in a single style rule.
// Each value in the list corresponds to the value at that same position in the other properties.
// - - - - - - - - - - - - - - - - - - - - - - - - -
@mixin animation($animations...) {
  @include prefixer(animation, $animations, webkit moz spec);
}

// Name of any animation as a string. [keyframename | none | initial | inherit]
// - - - - - - - - - - - - - - - - - - - - - - - - -
@mixin animation-name($names...) {
  // @if contains("none initial inherit", $names) == false or $names != "string" {
  //   @error "`animation-name` supports only `keyframename | none | initial | inherit` you used #{$names}";
  //   @return "error";
  // }

  @include prefixer(animation-name, $names, webkit moz spec);
}

// Duration of the entire animation in seconds. [time | initial | inherit]
// - - - - - - - - - - - - - - - - - - - - - - - - -
@mixin animation-duration($times...) {
  // @if contains("initial inherit", $times) == false or $times != "number" {
  //   @error "`animation-duration` supports only `time | initial | inherit` you used #{$times}";
  //   @return "error";
  // }

  @include prefixer(animation-duration, $times, webkit moz spec);
}

// The timing function(s) to be used between keyframes. [ease | linear | ease-in | ease-out | ease-in-out | cubic-bezier($number, $number, $number, $number)]
// - - - - - - - - - - - - - - - - - - - - - - - - -
@mixin animation-timing-function($motions...) {
  @include prefixer(animation-timing-function, $motions, webkit moz spec);
}

// The number of times an animation cycle is played. [number | infinite | initial | inherit]
// - - - - - - - - - - - - - - - - - - - - - - - - -
@mixin animation-iteration-count($values...) {
  // @if contains("infinite initial inherit", $values) == false or $values != "number" {
  //   @error "`animation-iteration-count` supports only `number | infinite | initial | inherit` you used #{$values}";
  //   @return "error";
  // }

  @include prefixer(animation-iteration-count, $values, webkit moz spec);
}

// Whether or not the animation should play in reverse on alternate cycles. [normal | reverse | alternate | alternate-reverse | initial | inherit]
// - - - - - - - - - - - - - - - - - - - - - - - - -
@mixin animation-direction($directions...) {
  // @if contains("normal reverse alternate alternate-reverse initial inherit", $directions) == false {
  //   @error "`animation-direction` supports only `normal | reverse | alternate | alternate-reverse | initial | inherit` you used #{$directions}";
  //   @return "error";
  // }

  @include prefixer(animation-direction, $directions, webkit moz spec);
}

// Whether the animation is running or paused. [running | paused | initial | inherit]
// - - - - - - - - - - - - - - - - - - - - - - - - -
@mixin animation-play-state($states...) {
  // @if contains("running paused initial inherit", $states) == false {
  //   @error "`animation-play-state` supports only `running | paused | initial | inherit` you used #{$states}";
  //   @return "error";
  // }

  @include prefixer(animation-play-state, $states, webkit moz spec);
}

// The animation-delay property specifies a delay for the start of an animation. [time | initial | inherit]
// - - - - - - - - - - - - - - - - - - - - - - - - -
@mixin animation-delay($times...) {
  @include prefixer(animation-delay, $times, webkit moz spec);
}

// What values are applied by the animation outside the time it is executing. [none | forwards | backwards | both | initial | inherit]
// - - - - - - - - - - - - - - - - - - - - - - - - -
@mixin animation-fill-mode($modes...) {
  // @if contains("none forwards backwards both initial inherit", $modes) == false {
  //   @error "`animation-fill-mode` supports only `none | forwards | backwards | both | initial | inherit` you used #{$modes}";
  //   @return "error";
  // }

  @include prefixer(animation-fill-mode, $modes, webkit moz spec);
}

/// Change the appearance for Mozilla, Webkit and possibly the future.
/// The appearance property is currently not present in any newer CSS specification.
///
/// There is no official list of accepted values, but you might check these source:
///
///   * [Mozilla](https://developer.mozilla.org/en/CSS/-moz-appearance)
///   * [Webkit](http://code.google.com/p/webkit-mirror/source/browse/Source/WebCore/css/CSSValueKeywords.in?spec=svnf1aea559dcd025a8946aa7da6e4e8306f5c1b604&r=63c7d1af44430b314233fea342c3ddb2a052e365)
///     (search for 'appearance' within the page)
///
/// @example scss - Usage
///   .appearance {
///     @include appearance(normal);
///   }
///
/// @example css - CSS Output
///   .appearance {
///     -webkit-appearance: normal;
///     -moz-appearance: normal;
///     appearance: normal;
///   }
///
/// @param {String} $value [normal | icon | window | button | menu | field]
@mixin appearance($value) {
  // There is no caniuse tracking for appearance.
  $value: unquote($value);
  @include prefixer(appearance, $value, webkit moz spec);
}

/// The backface-visibility property defines whether or not an
/// element should be visible when not facing the screen.
///
/// @example scss - Usage
///   .backface-visibility {
///     @include backface-visibility(visible);
///   }
///
/// @example css - CSS Output
///   .backface-visibility {
///     -webkit-backface-visibility: visible;
///     backface-visibility: visible;
///   }
///
/// @param {string} $visibility [visible | hidden | initial | inherit]
@mixin backface-visibility($visibility) {
  $visibility: unquote($visibility);
  @include prefixer(backface-visibility, $visibility, webkit spec);
}

/// The border-image CSS property allows drawing an image on the borders of elements.
///
/// @example scss - Usage
///   .border-image {
///     @include border-image(url(border.png) 30 round);
///   }
///
/// @example css - CSS Output
///   .border-image {
///     -webkit-border-image: url(border.png) 30 round;
///     -moz-border-image: url(border.png) 30 round;
///     -o-border-image: url(border.png) 30 round;
///     border-image: url(border.png) 30 round;
///   }
///
/// @param {String} $visibility [source slice width outset repeat | initial | inherit]
@mixin border-image($borders...) {
  $webkit-borders: ();
  $spec-borders: ();

  @each $border in $borders {
    $webkit-border: ();
    $spec-border: ();
    $border-type: type-of($border);

    @if $border-type == string or list {
      $border-str:    if($border-type == list, nth($border, 1), $border);
      $url-str:       str-slice($border-str, 1, 3);
      $gradient-type: str-slice($border-str, 1, 6);

      @if $url-str == "url" {
        $webkit-border: $border;
        $spec-border:   $border;
      } @else if $gradient-type == "linear" {
        $gradients: linear-gradient-parser("#{$border}");
        $webkit-border: map-get($gradients, webkit-image);
        $spec-border:   map-get($gradients, spec-image);
      } @else if $gradient-type == "radial" {
        $gradients: radial-gradient-parser("#{$border}");
        $webkit-border: map-get($gradients, webkit-image);
        $spec-border:   map-get($gradients, spec-image);
      } @else {
        $webkit-border: $border;
        $spec-border:   $border;
      }
    } @else {
      $webkit-border: $border;
      $spec-border:   $border;
    }

    $webkit-borders: append($webkit-borders, $webkit-border, comma);
    $spec-borders:   append($spec-borders, $spec-border, comma);
  }

  @include prefixer(border-image, $webkit-borders, webkit moz o);
  border-image: $spec-borders;
  border-style: solid;
}

/// Opacity should be on a 100 point scale (0-100 instead of 0.0-1.0)
/// This should be used to supplement a normal border definition as it
/// only deals with the 'border-color' property.
@mixin border-opacity($color, $opacity) {
  $opacity: $opacity / 100;

  /// Unsupporting browsers get this
  border-color: $color;

  /// Browsers that support RGBA will get this instead
  border-color: rgba($color, $opacity);

  /// Prevent the element's background from reaching the edge of the border
  background-clip: config-get("i-border-opacity");
}

/// Round all corners by a specific amount, defaults to value of `config-get("i-border-radius")`.
///
/// When two values are passed, the first is the horizontal radius
/// and the second is the vertical radius.
///
/// Note: webkit does not support shorthand syntax for several corners at once.
/// So in the case where you pass several values only the first will be passed to webkit.
///
/// @example scss - Usage
///   .simple   {
///     @include border-radius(4px, 4px);
///   }
///   .compound {
///     @include border-radius(2px 5px, 3px 6px);
///   }
///   .crazy    {
///     @include border-radius(1px 3px 5px 7px, 2px 4px 6px 8px)
///   }
///
/// @example css - CSS Output
///   .simple {
///     -moz-border-radius: 4px / 4px;
///     -webkit-border-radius: 4px 4px;
///     border-radius: 4px / 4px;
///   }
///   .compound {
///     -moz-border-radius: 2px 5px / 3px 6px;
///     -webkit-border-radius: 2px 3px;
///     border-radius: 2px 5px / 3px 6px;
///   }
///  .crazy {
///    -moz-border-radius: 1px 3px 5px 7px / 2px 4px 6px 8px;
///    -webkit-border-radius: 1px 2px;
///    border-radius: 1px 3px 5px 7px / 2px 4px 6px 8px;
///  }
@mixin border-radius($radius: config-get("i-border-radius"), $vertical-radius: false) {
  /// Legacy Webkit didn't understand the official shorthand syntax for specifying a vertical radius.
  $legacy-webkit-radius: first-value-of($radius);
  @if $vertical-radius {
    $legacy-webkit-radius: append($legacy-webkit-radius, first-value-of($vertical-radius));
  }

  @include prefix(border-radius, $legacy-webkit-radius, webkit);

  /// Official syntax for everyone else
  @include prefix(border-radius, if($vertical-radius, #{$radius} / #{$vertical-radius}, $radius), o ms moz spec);
}

/// Round radius at position by amount.
///
/// * legal values for `$vert`: `top`, `bottom`
/// * legal values for `$horz`: `left`, `right`
@mixin border-corner-radius($vert, $horz, $radius: config-get("i-border-radius")) {
  /// Support for mozilla's syntax for specifying a corner
  @include prefix("border-radius-#{$vert}#{$horz}", $radius, moz);
  /// Official syntax for everyone else
  @include prefix("border-#{$vert}-#{$horz}-radius", $radius, o ms webkit spec);
}

/// Round top-left corner only
@mixin border-top-left-radius($radius: config-get("i-border-radius")) {
  @include border-corner-radius(top, left, $radius);
}

/// Round top-right corner only
@mixin border-top-right-radius($radius: config-get("i-border-radius")) {
  @include border-corner-radius(top, right, $radius);
}

/// Round bottom-left corner only
@mixin border-bottom-left-radius($radius: config-get("i-border-radius")) {
  @include border-corner-radius(bottom, left, $radius);
}

/// Round bottom-right corner only
@mixin border-bottom-right-radius($radius: config-get("i-border-radius")) {
  @include border-corner-radius(bottom, right, $radius);
}

/// Round both top corners by amount
@mixin border-top-radius($radius: config-get("i-border-radius")) {
  @include border-top-left-radius($radius);
  @include border-top-right-radius($radius);
}

/// Round both right corners by amount
@mixin border-right-radius($radius: config-get("i-border-radius")) {
  @include border-top-right-radius($radius);
  @include border-bottom-right-radius($radius);
}

/// Round both bottom corners by amount
@mixin border-bottom-radius($radius: config-get("i-border-radius")) {
  @include border-bottom-left-radius($radius);
  @include border-bottom-right-radius($radius);
}

/// Round both left corners by amount
@mixin border-left-radius($radius: config-get("i-border-radius")) {
  @include border-top-left-radius($radius);
  @include border-bottom-left-radius($radius);
}

/// Provides cross-browser for Webkit, Gecko, and CSS3 box shadows
/// when one or more box shadows are needed.
/// Each shadow argument should adhere to the standard css3 syntax
/// for the box-shadow property.
@mixin box-shadow($shadow...) {
  @if(length($shadow) < 0) {
    $shadow: compact(if(config-get("i-box-shadow-inset"), inset, null) config-get("i-box-shadow-h-offset") config-get("i-box-shadow-v-offset") config-get("i-box-shadow-blur") config-get("i-box-shadow-spread") config-get("i-box-shadow-color"));
  }

  @include prefixer(box-shadow, $shadow, webkit moz spe);
}

/// Provides a single cross-browser CSS box shadow for Webkit, Gecko, and CSS3.
/// Includes default arguments for color, horizontal offset, vertical offset, blur length, spread length, and inset.
@mixin single-box-shadow($hoff: null, $voff: null, $blur: null, $spread: null, $color: null, $inset: config-get("i-box-shadow-inset")) {
  /// Handle legacy argument order
  @if not ($hoff == none or $hoff == null) and type-of($hoff) != number {
    $tmp-color: $color;
    $color: $hoff;
    $hoff: $voff;
    $voff: $blur;
    $blur: $spread;
    $spread: $tmp-color;
  }

  /// Need to set these defaults here instead of the arglist to support the above backwards compat handling
  @if $hoff == null {
    $hoff: config-get("i-box-shadow-h-offset");
  }

  @if $voff == null {
    $hoff: config-get("i-box-shadow-v-offset");
  }

  @if $blur == null {
    $blur: config-get("i-box-shadow-blur");
  }

  @if $spread == null {
    $spread: config-get("i-box-shadow-spread");
  }

  @if $color  == null {
    $color: config-get("i-box-shadow-color");
  }

  @if not ($inset == true or $inset == false or $inset == null or $inset == inset) {
    @warn "$inset expected to be true or the inset keyword. Got #{$inset} instead. Using: inset";
  }

  @if $hoff == none {
    @include box-shadow(none);
  } @else {
    $full: $hoff $voff;

    @if $blur {
      $full: $full $blur;
    }

    @if $spread {
      $full: $full $spread;
    }

    @if $color {
      $full: $full $color;
    }

    @if $inset {
      $full: inset $full;
    }

    @include box-shadow($full);
  }
}

/// Enables hyphenation for text.
///
/// @example scss - Usage
///   .text-container {
///     @include hyphens(auto);
///   }
@mixin hyphens($hyphenation: manual) {
  /// none | manual | auto
  @include prefixer(hyphens, $hyphenation, webkit moz ms spec);

  -webkit-hyphenate-character: "\2010";
  -webkit-hyphenate-limit-after: 1;
  -webkit-hyphenate-limit-before: 3;
}

/// Adds keyframes blocks for supported prefixes, removing redundant prefixes in the block"s content
@mixin keyframe ($animation-name) {
  @include prefixer-content("keyframes #{$animation-name}", webkit moz ms o spec) {
    @content;
  }
}

/// Shortcode for transitions transform
///
/// @param {Time}   $duration
/// @param {String} $timing
/// @param {Time}   $delay
/// @param {List}   $preface
///
/// @example scss - Usage
///   .transition-transform {
///     @include transition-transform(0.8s, linear);
///   }
///
/// @example css - CSS Output
///   .transition-transform {
///     -webkit-transition: -webkit-transform 0.8s linear 0s;
///     -moz-transition: -moz-transform 0.8s linear 0s;
///     -ms-transition: -ms-transform 0.8s linear 0s;
///     -o-transition: -o-transform 0.8s linear 0s;
///     transition: transform 0.8s linear 0s;
///   }
@mixin transition-transform($duration, $timing, $delay:0s, $preface:webkit moz ms o spec) {
  @each $browser in $preface {
    @if($browser == spec) {
      transition: transform $duration $timing $delay;
    } @else {
      @include prefixer(transition, -#{$browser}-transform $duration $timing $delay, $browser);
    }
  }
}
